#!/usr/bin/env python

import copy
import getopt
import os
import sys
from sys import exit

import algorithms
import common_complexity
import common_functions
from common_functions import err, expand_macros, isverbose, verbose, warn
import common_metric
import common_stats
import datalib
import iterators
import plotlib
import wfutil

################################################################################
#TCRIT = 2.132    # 95% confidence for 4 degrees of freedom (5 pairs of points)
TCRIT_DEFAULT = (1.833,20,10)    # 95% confidence for 9 degrees of freedom (10 pairs of points)
#TCRIT = 1.796    # 95% confidence for 11 degrees of freedom (12 pairs of points)
################################################################################
TBOTTOM_DEFAULT = 0.0
TTOP_DEFAULT = 0.25

DEFAULT_OUTPUT = './plot.eps'

TTEST_LINETYPE = plotlib.CurveStyle.DOTTED
CLASSIFICATION_LINETYPES = {'Driven': plotlib.CurveStyle.SOLID,
                            'Passive': plotlib.CurveStyle.DASHED,
                            'Fitness': plotlib.CurveStyle.DASHDOT}


####################################################################################
###
### FUNCTION main()
###
####################################################################################
def main():
    clauses, rundirs = parse_argv( sys.argv )

    classify_runs( rundirs )
    group_runs( rundirs )

    curveDatas = [ curveData
                   for clause in clauses
                   for curveData in clause.createCurveDatas(rundirs) ]

    macros = create_macros( clauses,
                            rundirs,
                            curveDatas )

    doc, plot = init_plot( macros, curveDatas )

    config_style( plot, curveDatas )
    config_legend( plot, curveDatas )

    for curveData in curveDatas:
        plot_curve( plot, curveData )

    finalize_plot( doc, plot )

    return 0


####################################################################################
###
### FUNCTION parse_argv()
###
####################################################################################
def parse_argv( argv ):
    if len(argv) == 1:
        show_usage()

    if argv[1] == 'help':
        if len(argv) > 2:
            show_usage( arg = argv[2] )
        else:
            show_usage()

    OPTS = [
        # Long                  Short       Arg
        ( 'output',             'o',        True ),
        ( 'classifications',    'C',        True),
        ( 'group',              'g',        True),
        ( 'xrange',             None,       True ),
        ( 'y1range',            None,       True ),
        ( 'y2range',            None,       True ),
        ( 'tgroups',            None,       True ),
        ( 'tcrit',              None,       True ),
        ( 'ttop',               None,       True ),
        ( 'tbottom',            None,       True ),
        ( 'legend',             'l',        False ),
        ( 'noLegend',           'L',        False ),
        ( 'noview',             'V',        False),
        ( 'color',              'c',        False),
        ( 'title',              None,       True ),
        ( 'xlabel',             None,       True ),
        ( 'y1label',            None,       True ),
        ( 'y2label',            None,       True ),
        ( 'rmargin',            None,       True ),
        ]

    def __optname( opt ):
        opt = opt[0].strip( '-' )
        for x in OPTS:
            if opt == x[0] or opt == x[1]:
                return x[0]
        assert( False )

    def __parse_range( opt ):
        try:
            fields = opt[1].split(',')
            if len(fields) != 2:
                raise Exception( "Requires 2 comma-separated values" )
            return ( float(fields[0]), float(fields[1]) )
        except Exception, x:
            optname = __optname( opt )
            err( "Invalid value for " + optname + ": " + str(x) )

    def __parse_float( opt, minval = None, maxval = None ):
        try:
            val = float(opt[1])
            if minval != None:
                if val < minval:
                    raise Exception( "Must be >= " + str(minval) )
            if maxval != None:
                if val > maxval:
                    raise Exception( "Must be <= " + str(maxval) )
            return val
        except Exception, x:
            optname = __optname( opt )
            err( "Invalid value for " + optname + ": " + str(x) )

    def __parse_int( opt, minval = None, maxval = None ):
        try:
            val = int(opt[1])
            if minval != None:
                if val < minval:
                    raise Exception( "Must be >= " + str(minval) )
            if maxval != None:
                if val > maxval:
                    raise Exception( "Must be <= " + str(maxval) )
            return val
        except Exception, x:
            optname = __optname( opt )
            err( "Invalid value for " + optname + ": " + str(x) )

    longopts = []
    shortopts = ''

    for opt in OPTS:
        if opt[0]:
            longopts.append( opt[0] + ('=' if opt[2] else '') )
        if opt[1]:
            shortopts += opt[1] + (':' if opt[2] else '')

    try:
        opts, args = getopt.getopt( argv[1:], shortopts, longopts )
    except getopt.GetoptError, x:
        err( x )

    for opt in opts:
        optname = __optname(opt)
        optval = opt[1]
        
        if optname == 'output':
            GlobalOptions.output = optval
        elif optname == 'classifications':
            try:
                GlobalOptions.classifications = common_functions.normalize_classifications( optval.split(',') )
            except common_functions.IllegalAbbreviationError, x:
                err(str(x))
        elif optname == 'group':
            try:
                GlobalOptions.group = common_functions.expand_abbreviations( optval,
                                                                             ['auto',
                                                                              'classification',
                                                                              'overlay',
                                                                              'parentdir'],
                                                                             case_sensitive = False )
            except common_functions.IllegalAbbreviationError, x:
                err( x )
        elif optname == 'xrange':
            GlobalOptions.xrange = __parse_range( opt )
        elif optname == 'y1range':
            GlobalOptions.y1range = __parse_range( opt )
        elif optname == 'y2range':
            GlobalOptions.y2range = __parse_range( opt )
        elif optname == 'tgroups':
            GlobalOptions.tgroups = optval
        elif optname == 'tcrit':
            GlobalOptions.tcrit = __parse_float( opt )
        elif optname == 'ttop':
            GlobalOptions.ttop = __parse_float( opt, 0, 1 )
        elif optname == 'tbottom':
            GlobalOptions.tbottom = __parse_float( opt, 0, 1 )
        elif optname == 'legend':
            GlobalOptions.legend_individual = True
        elif optname == 'noLegend':
            GlobalOptions.legend_meta = False
        elif optname == 'noview':
            GlobalOptions.view = False
        elif optname == 'color':
            GlobalOptions.color = True
        elif optname == 'title':
            GlobalOptions.title = optval
        elif optname == 'xlabel':
            GlobalOptions.xlabel = optval
        elif optname == 'y1label':
            GlobalOptions.y1label = optval
        elif optname == 'y2label':
            GlobalOptions.y2label = optval
        elif optname == 'rmargin':
            GlobalOptions.rmargin = __parse_int( opt )
        else: assert( False )

    args_clauses = [[]]
    for arg in args:
        if arg == ':':
            args_clauses.append( [] )
        else:
            args_clauses[-1].append( arg )

    clauses = []

    for args_clause in args_clauses:
        clauses.append( Clause(args_clause) )

    args = clauses[-1].drop_global_args()

    rundirs = []

    group = None
    new_group = False
    for arg in args:
        if arg == '@group':
            new_group = True
        elif new_group:
            group = arg
            new_group = False
        else:
            try:
                paths = common_functions.find_run_paths( [arg] )
            except common_functions.InvalidDirError, e:
                err( str(e) )

            for path in paths:
                rundirs.append( RunDir(path, group) )

    if not len(rundirs):
        err( "Must specify at least one run directory." )

    return clauses, rundirs


####################################################################################
###
### CLASS GlobalOptions
###
####################################################################################
class GlobalOptions:
    output = DEFAULT_OUTPUT
    classifications = common_functions.CLASSIFICATIONS
    group = 'auto'
    xrange = None
    y1range = None
    y2range = None
    tgroups = None
    tcrit = TCRIT_DEFAULT[0]
    ttop = TTOP_DEFAULT
    tbottom = TBOTTOM_DEFAULT
    legend_individual = False
    legend_meta = True
    view = True
    color = False
    title = '{TITLE}'
    xlabel = '{XLABEL}'
    y1label = '{Y1LABEL}'
    y2label = '{Y2LABEL}'
    rmargin = None


####################################################################################
###
### CLASS RunDir
###
####################################################################################
class RunDir:
    def __init__( self, path, group ):
        self.path = path
        self.group = group
        self.classification = None

    def __str__( self ):
        return "RunDir(path=%s, group=%s, classification=%s)" % (self.path, self.group, self.classification)


####################################################################################
###
### CLASS RunData
###
####################################################################################
class RunData:
    def __init__( self,
                  rundir,
                  valuename,
                  table,
                  xcolname,
                  ycolname_default ):
        self.rundir = rundir
        self.valuename = valuename
        self.table = table
        self.xcolname = xcolname
        self.ycolname_default = ycolname_default


####################################################################################
###
### CLASS CurveData
###
####################################################################################
class CurveData:
    def __init__( self,
                  clause,
                  valuename,
                  valueattr,
                  datatype,
                  curvetype,
                  table,
                  xcolname,
                  ycolnames,
                  yaxis,
                  groups,
                  rundirs,
                  classifications ):
        self.clause = clause
        self.valuename = valuename
        self.valueattr = valueattr
        self.datatype = datatype
        self.curvetype = curvetype
        self.table = table
        self.xcolname = xcolname
        self.ycolnames = ycolnames
        self.yaxis = yaxis
        self.rundirs = tuple( set(rundirs) )
        self.groups = tuple( set(groups) )
        self.classifications = tuple( set(classifications) )


####################################################################################
###
### CLASS Mode
###
####################################################################################
class Mode:
    #------------------------------------------------------------
    #--- FUNCTION __get_modes()
    #------------------------------------------------------------
    MODES = None
    @staticmethod
    def __get_modes():
        if not Mode.MODES:
            Mode.MODES = [
                NeuralComplexityMode(),
                GraphMetricMode(),
                StatsMode(),
                BarrierPosMode(),
                GeneMode(),
                AdhocMode()
                ]
        return Mode.MODES

    #------------------------------------------------------------
    #--- FUNCTION __init__()
    #------------------------------------------------------------
    def __init__( self,
                  name,
                  title,
                  numargs,
                  isAvr,
                  default_recent_type,   # if None, then mode doesn't use -r
                  default_valuenames ):  # if None, then doesn't use -v
        self.name = name
        self.title = title
        self.numargs = numargs
        self.isAvr = isAvr
        self.default_recent_type = default_recent_type
        self.default_valuenames = default_valuenames

    #------------------------------------------------------------
    #--- FUNCTION get_mode()
    #------------------------------------------------------------
    @staticmethod
    def get_mode( name ):
        name = Mode.expand_name( name )
        modes = filter( lambda x: x.name == name, Mode.__get_modes() )
        if len(modes) != 1:
            err( "Invalid mode name: " + name )
        return modes[0]

    #------------------------------------------------------------
    #--- FUNCTION get_names()
    #------------------------------------------------------------
    @staticmethod
    def get_names():
        return map( lambda x: x.name, Mode.__get_modes() )

    #------------------------------------------------------------
    #--- FUNCTION expand_name()
    #------------------------------------------------------------
    @staticmethod
    def expand_name( name ):
        try:
            return common_functions.expand_abbreviations( name,
                                                          Mode.get_names(),
                                                          case_sensitive = False )
        except common_functions.IllegalAbbreviationError, x:
            err( "Failed disambiguating mode name. " + str(x) )

    #------------------------------------------------------------
    #--- FUNCTION is_name()
    #------------------------------------------------------------
    @staticmethod
    def is_name( name ):
        return Mode.expand_name( name ) != None

    #------------------------------------------------------------
    #--- FUNCTION get_valuenames_title()
    #------------------------------------------------------------
    def get_valuenames_title( self, valuenames ):
        return ", ".join( valuenames )

    #------------------------------------------------------------
    #--- FUNCTION __parse_opts()
    #------------------------------------------------------------
    def __parse_opts( self, argv ):
        longopts = []
        shortopts = ''

        if self.default_recent_type != None:
            shortopts += 'r:'

        if self.default_valuenames != None:
            shortopts += 'v:'

        if self.isAvr:
            shortopts += "mnxewMNXEW"
        else:
            shortopts += "mME"

        # ttest
        longopts += ['tgroups=']
        shortopts += "pt"

        # Misc general
        shortopts += "sd"
        longopts += ['y2']

        try:
            return  getopt.getopt( argv[1:], shortopts, longopts )
        except getopt.GetoptError, x:
            err( "(mode " + self.name + ") " + str(x) )

    #------------------------------------------------------------
    #--- FUNCTION init_valuenames()
    #------------------------------------------------------------
    def init_valuenames( self, mode_opts, opts, args ):
        if self.default_valuenames:
            return self.default_valuenames
        else:
            assert( False ) # Derived class must provide logic

    #------------------------------------------------------------
    #--- FUNCTION split_global_args()
    #------------------------------------------------------------
    def split_global_args( self, argv ):
        opts, args = self.__parse_opts( argv )

        num_global_args = len(args) - self.numargs
        if num_global_args < 0:
            err( "Missing args for mode " + self.name )

        global_args = args[-num_global_args:]
        argv = argv[:-num_global_args]

        return argv, global_args

    #------------------------------------------------------------
    #--- FUNCTION parse_argv
    #------------------------------------------------------------
    def parse_argv( self, argv ):
        opts, args = self.__parse_opts( argv )

        if len(args) > self.numargs:
            err( "Unexpected arg for mode %s (%s)" % (self.name, args[self.numargs]) )

        general_opts = {
            'tgroups': GlobalOptions.tgroups,
            'smooth': False,
            'dots': False,
            'yaxis': 1,
            }

        mode_opts = {}
        if self.default_recent_type:
            mode_opts['recent_type'] = self.default_recent_type

        valueattrs = { "meta": set(), "individual": set(), "ttest": set() }

        # This will typically be default_valuenames, but Adhoc has special needs.
        valuenames = self.init_valuenames( mode_opts, opts, args )

        #
        # Process Options
        #
        for opt in opts:
            optname = opt[0].strip( '-' )
            optval = opt[1]

            #
            # General Options
            #
            if optname == 'tgroups':
                general_opts['tgroups'] = optval
            elif optname == 's':
                general_opts['smooth'] = True
            elif optname == 'd':
                general_opts['dots'] = True
            elif optname == 'y2':
                general_opts['yaxis'] = 2
            #
            # Data
            #
            elif optname == 'r':
                try:
                    mode_opts['recent_type'] = common_functions.expand_abbreviations( optval,
                                                                                      common_functions.RECENT_TYPES,
                                                                                      case_sensitive = False )
                except common_functions.IllegalAbbreviationError, x:
                    err( "Failed processing -r: " + str(x) )
            elif optname == 'v':
                valuenames = optval.split( ',' )
            #
            # Curves -- Individual Run
            #
            elif optname == 'm':
                valueattrs['individual'].add( 'default' )
            elif optname == 'n':
                valueattrs['individual'].add( 'min' )
            elif optname == 'x':
                valueattrs['individual'].add( 'max' )
            elif optname == 'e':
                valueattrs['individual'].add( 'err' )
                valueattrs['individual'].add( 'default' )
            elif optname == 'w':
                valueattrs['individual'].add( 'whisker' )
            #
            # Curves -- Meta
            #
            elif optname == 'M':
                valueattrs['meta'].add( 'default' )
            elif optname == 'N':
                valueattrs['meta'].add( 'min' )
            elif optname == 'X':
                valueattrs['meta'].add( 'max' )
            elif optname == 'E':
                valueattrs['meta'].add( 'err' )
                valueattrs['meta'].add( 'default' )
            elif optname == 'W':
                valueattrs['meta'].add( 'whisker' )
            #
            # Curves -- TTest
            #
            elif optname == 'p':
                valueattrs['ttest'].add( 'pval' )
            elif optname == 't':
                valueattrs['ttest'].add( 'tval' )
            else:
                err( "Unknown mode option: " + optname )

        #
        # Set default value attribute if none specified
        #
        if len(valueattrs['meta']) == 0 and len(valueattrs['individual']) == 0:
            valueattrs['individual'].add( 'default' )


        return general_opts, mode_opts, valuenames, valueattrs

    #------------------------------------------------------------
    #--- FUNCTION createRunDatas()
    #------------------------------------------------------------
    def createRunDatas( self, general_opts, mode_opts, valuenames, valueattrs, rundirs ):
        err( "Impl " + self.name + " createRunDatas()" )

    #------------------------------------------------------------
    #--- FUNCTION usage_valuenames()
    #------------------------------------------------------------
    def usage_valuenames( self ):
        if self.default_valuenames:
            print """\
     -v <V>[,<V>]...
               Specify values to be plotted.
               ( default = %s )
            """ % ','.join(self.default_valuenames)


####################################################################################
###
### CLASS NeuralComplexityMode
###
####################################################################################
class NeuralComplexityMode( Mode ):

    #------------------------------------------------------------
    #--- FUNCTION __init()__
    #------------------------------------------------------------
    def __init__( self ):
        Mode.__init__( self,
                       name = 'neuralComplexity',
                       title = 'Neural Complexity',
                       numargs = 0,
                       isAvr = True,
                       default_recent_type = 'Recent',
                       default_valuenames = ['P'] )

    #------------------------------------------------------------
    #--- FUNCTION get_valuenames_title()
    #------------------------------------------------------------
    def get_valuenames_title( self, valuenames ):
        valuetitles = [ common_complexity.get_name(x)
                        for x in valuenames ]
        return self.title + " (" + ", ".join(valuetitles) + ")"

    #------------------------------------------------------------
    #--- FUNCTION createRunDatas()
    #------------------------------------------------------------
    def createRunDatas( self, general_opts, mode_opts, valuenames, valueattrs, rundirs ):
        runDatas = []

        for rundir in rundirs:
            tables = common_complexity.parse_avr( rundir.path,
                                                  recent_type = mode_opts['recent_type'],
                                                  complexities = valuenames )
            for complexity, table in tables.items():
                runDatas.append( RunData(rundir,
                                         complexity,
                                         table,
                                         'Timestep',
                                         'mean') )

        return runDatas

    #------------------------------------------------------------
    #--- FUNCTION usage_valuenames()
    #------------------------------------------------------------
    def usage_valuenames( self ):
        print """\
     -v <C>[,<C>]...
               Specify complexity types to be plotted.
               ( default = %s )
        """ % ','.join(self.default_valuenames)


####################################################################################
###
### CLASS GraphMetricMode
###
####################################################################################
class GraphMetricMode( Mode ):

    #------------------------------------------------------------
    #--- FUNCTION __init()__
    #------------------------------------------------------------
    def __init__( self ):
        Mode.__init__( self,
                       name = 'graphMetric',
                       title = 'Graph Metric',
                       isAvr = True,
                       numargs = 0,
                       default_recent_type = 'Recent',
                       default_valuenames = ['cc_a_bu'] )

    #------------------------------------------------------------
    #--- FUNCTION get_valuenames_title()
    #------------------------------------------------------------
    def get_valuenames_title( self, valuenames ):
        valuetitles = [ common_metric.get_name(x)
                        for x in valuenames ]
        return ", ".join( valuetitles )

    #------------------------------------------------------------
    #--- FUNCTION createRunDatas()
    #------------------------------------------------------------
    def createRunDatas( self, general_opts, mode_opts, valuenames, valueattrs, rundirs ):
        runDatas = []

        for rundir in rundirs:
            tables = common_metric.parse_avr( rundir.path,
                                              recent_type = mode_opts['recent_type'],
                                              metrics = valuenames )
            for metric, table in tables.items():
                runDatas.append( RunData(rundir,
                                         metric,
                                         table,
                                         'Timestep',
                                         'mean') )

        return runDatas

    #------------------------------------------------------------
    #--- FUNCTION usage_valuenames()
    #------------------------------------------------------------
    def usage_valuenames( self ):
        print """\
     -v <M>[,<M>]...
               Specify metrics to be plotted.
               ( default = %s )
        """ % ','.join(self.default_valuenames)


####################################################################################
###
### CLASS StatsMode
###
####################################################################################
class StatsMode( Mode ):

    #------------------------------------------------------------
    #--- FUNCTION __init()__
    #------------------------------------------------------------
    def __init__( self ):
        Mode.__init__( self,
                       name = 'stats',
                       title = 'Stats',
                       isAvr = False,
                       numargs = 0,
                       default_recent_type = None,
                       default_valuenames = ['agents'] )

    #------------------------------------------------------------
    #--- FUNCTION createRunDatas()
    #------------------------------------------------------------
    def createRunDatas( self, general_opts, mode_opts, valuenames, valueattrs, rundirs ):
        runDatas = []

        for rundir in rundirs:
            tables = common_stats.parse_stats( rundir.path, types = valuenames )

            for type, table in tables.items():
                runDatas.append( RunData(rundir,
                                         type,
                                         table,
                                         'step',
                                         'value') )

        return runDatas

    #------------------------------------------------------------
    #--- FUNCTION usage_valuenames()
    #------------------------------------------------------------
    def usage_valuenames( self ):
        print """\
     -v <S>[,<S>]...
               Specify stats to be plotted.
               ( default = %s )
        """ % ','.join(self.default_valuenames)


####################################################################################
###
### CLASS BarrierPosMode
###
####################################################################################
class BarrierPosMode( Mode ):
    PROPS = ["X1", "Z1", "X2", "Z2"]

    #------------------------------------------------------------
    #--- FUNCTION __init()__
    #------------------------------------------------------------
    def __init__( self ):
        Mode.__init__( self,
                       name = 'barrierpos',
                       title = 'Barrier Position',
                       isAvr = False,
                       numargs = 0,
                       default_recent_type = None,
                       default_valuenames = ['0_Z2'] )

    #------------------------------------------------------------
    #--- FUNCTION get_valuenames_title()
    #------------------------------------------------------------
    def get_valuenames_title( self, valuenames ):
        valuetitles = [ 'Barrier'+id+'.'+prop
                        for id, prop in map(BarrierPosMode.__parse_valuename, valuenames) ]

        return ", ".join( valuetitles )

    #------------------------------------------------------------
    #--- FUNCTION createRunDatas()
    #------------------------------------------------------------
    def createRunDatas( self, general_opts, mode_opts, valuenames, valueattrs, rundirs ):
        runDatas = []

        for rundir in rundirs:
            for valuename in valuenames:
                id, prop = BarrierPosMode.__parse_valuename( valuename )

                path = os.path.join( rundir.path, "condprop/barrier%s.txt" % id )
                table = datalib.parse( path,
                                       tablenames = ['Values'],
                                       required = datalib.REQUIRED,
                                       keycolname = 'Time' )[ 'Values' ]

                runDatas.append( RunData(rundir,
                                         valuename,
                                         table,
                                         'Time',
                                         prop) )

        return runDatas

    #------------------------------------------------------------
    #--- FUNCTION usage_valuenames()
    #------------------------------------------------------------
    def usage_valuenames( self ):
        print """\
     -v <B>[,<B>]...
               Specify barriers to be plotted, where <B> is in the form
               <barrier id>_<prop>. Where <prop> can be one of
               {%s}.
               ( default = %s )
        """ % ( ', '.join(BarrierPosMode.PROPS),
                ','.join(self.default_valuenames) )

    #------------------------------------------------------------
    #--- FUNCTION __parse_valuename
    #------------------------------------------------------------
    @staticmethod
    def __parse_valuename( valuename ):
        fields = valuename.split( '_' )
        if len(fields) != 2:
            err( "Invalid barrier valuename (%s). Expecting <id>_<prop>." % valuename )
        try:
            int(fields[0])
        except:
            err( "Invalid barrier id (%s). Expecting int." % fields[0] )

        
        if not fields[1] in BarrierPosMode.PROPS:
            err( "Invalid barrier prop (%s). Expecting one of: %s." % fields[1], ', '.join(BarrierPosMode.PROPS) )
                     
        return fields[0], fields[1]


####################################################################################
###
### CLASS GeneMode
###
####################################################################################
class GeneMode( Mode ):
    TYPES = ["normalized", "interpolated"]

    #------------------------------------------------------------
    #--- FUNCTION __init()__
    #------------------------------------------------------------
    def __init__( self ):
        Mode.__init__( self,
                       name = 'gene',
                       title = 'Gene',
                       isAvr = False,
                       numargs = 0,
                       default_recent_type = None,
                       default_valuenames = ['MutationRate_interpolated'] )

    #------------------------------------------------------------
    #--- FUNCTION get_valuenames_title()
    #------------------------------------------------------------
    def get_valuenames_title( self, valuenames ):
        valuetitles = [ name + ( ' (' + type.capitalize() + ')' if type != 'interpolated' else '')
                        for name, type in map(GeneMode.__parse_valuename, valuenames) ]

        return ", ".join( valuetitles )

    #------------------------------------------------------------
    #--- FUNCTION createRunDatas()
    #------------------------------------------------------------
    def createRunDatas( self, general_opts, mode_opts, valuenames, valueattrs, rundirs ):
        runDatas = []

        for rundir in rundirs:
            for valuename in valuenames:
                name, type = GeneMode.__parse_valuename( valuename )

                path = os.path.join( rundir.path, "genome/subset_mean.txt" )
                tablename = type.capitalize()
                table = datalib.parse( path,
                                       tablenames = [tablename],
                                       required = datalib.REQUIRED,
                                       keycolname = 'Timestep' )[ tablename ]

                runDatas.append( RunData(rundir,
                                         valuename,
                                         table,
                                         'Timestep',
                                         name) )

        return runDatas

    #------------------------------------------------------------
    #--- FUNCTION usage_valuenames()
    #------------------------------------------------------------
    def usage_valuenames( self ):
        print """\
     -v <G>[,<G>]...
               Specify genes to be plotted, where <G> is in the form
               <gene_name>_<type>. Where <type> can be one of
               {%s}.
               Also note that <type> can be an abbreviation.
               ( default = %s )
        """ % ( ', '.join(GeneMode.TYPES),
                ','.join(self.default_valuenames) )

    #------------------------------------------------------------
    #--- FUNCTION __parse_valuename
    #------------------------------------------------------------
    @staticmethod
    def __parse_valuename( valuename ):
        fields = valuename.split( '_' )
        if len(fields) != 2:
            err( "Invalid gene valuename (%s). Expecting <gene_name>_<type>." % valuename )

        gene = fields[0]
        type = fields[1]
        try:
            type = common_functions.expand_abbreviations( type,
                                                          GeneMode.TYPES,
                                                          case_sensitive = False )
        except common_functions.IllegalAbbreviationError, x:
            err( "Failed expanding gene valuname type: " + str(x) )
                     
        return gene, type


####################################################################################
###
### CLASS AdhocMode
###
####################################################################################
class AdhocMode( Mode ):

    #------------------------------------------------------------
    #--- FUNCTION __init()__
    #------------------------------------------------------------
    def __init__( self ):
        Mode.__init__( self,
                       name = 'adhoc',
                       title = 'Ad hoc',
                       isAvr = False,
                       numargs = 4,
                       default_recent_type = None,
                       default_valuenames = None )

    #------------------------------------------------------------
    #--- FUNCTION init_valuenames()
    #------------------------------------------------------------
    def init_valuenames( self, mode_opts, opts, args ):
        mode_opts['relpath'] = args[0]
        mode_opts['tablename'] = args[1]
        mode_opts['xcolname'] = args[2]
        mode_opts['ycolname'] = args[3]
        valuenames = ["%s[%s[%s]]" % (os.path.splitext( os.path.basename(mode_opts['relpath']) )[0],
                                      mode_opts['tablename'],
                                      mode_opts['ycolname'])]

        return valuenames

    #------------------------------------------------------------
    #--- FUNCTION createRunDatas()
    #------------------------------------------------------------
    def createRunDatas( self, general_opts, mode_opts, valuenames, valueattrs, rundirs ):
        runDatas = []

        for rundir in rundirs:
            path = os.path.join( rundir.path, mode_opts['relpath'] )
            table = datalib.parse( path,
                                   tablenames = [mode_opts['tablename']],
                                   required = datalib.REQUIRED,
                                   keycolname = mode_opts['xcolname'] )[mode_opts['tablename']]

            runDatas.append( RunData(rundir,
                                     valuenames[0],
                                     table,
                                     mode_opts['xcolname'],
                                     mode_opts['ycolname']) )

        return runDatas


####################################################################################
###
### CLASS Clause
###
####################################################################################
class Clause:
    #------------------------------------------------------------
    #--- FUNCTION __init__()
    #------------------------------------------------------------
    def __init__( self, argv ):
        if not len(argv):
            err( "Missing mode name" )

        self.mode = Mode.get_mode( argv[0] )
        self.argv = argv

    #------------------------------------------------------------
    #--- FUNCTION drop_global_args()
    #---
    #--- The last clause is going to have global args (e.g. run
    #--- directories) at the end of its argv. This method prunes
    #--- those args from this clause's argv and returns them.
    #------------------------------------------------------------
    def drop_global_args( self ):
        self.argv, global_args = self.mode.split_global_args( self.argv )

        return global_args

    #------------------------------------------------------------
    #--- FUNCTION createCurveDatas()
    #------------------------------------------------------------
    def createCurveDatas( self, rundirs ):
        general_opts, mode_opts, valuenames, valueattrs = self.mode.parse_argv( self.argv )
        runDatas = self.mode.createRunDatas( general_opts, mode_opts, valuenames, valueattrs, rundirs )

        curveDatas = []

        #
        # Create individual run CurveData
        #
        for runData in runDatas:
            for valueattr in valueattrs['individual']:
                if valueattr == 'default' or valueattr == 'min' or valueattr == 'max':
                    if valueattr == 'default':
                        ycolnames = [runData.ycolname_default]
                    else:
                        ycolnames = [valueattr]
                    curvetype = 'line'

                elif valueattr == 'err':
                    ycolnames = ['mean', 'mean_stderr']
                    curvetype = 'errorbar'

                elif valueattr == 'whisker':
                    ycolnames = ['q1','min','max','q3','median']
                    curvetype = 'whisker'

                else:
                    err( "Impl individual " + valueattr )

                curveDatas.append( CurveData(clause = self,
                                             valuename = runData.valuename,
                                             valueattr = valueattr,
                                             datatype = 'individual',
                                             curvetype = curvetype,
                                             table = runData.table,
                                             xcolname = runData.xcolname,
                                             ycolnames = ycolnames,
                                             yaxis = general_opts['yaxis'],
                                             groups = [runData.rundir.group],
                                             rundirs = [runData.rundir],
                                             classifications = [runData.rundir.classification]) )


        #
        # Create meta CurveData
        #
        if len( valueattrs['meta'] ):
            runDatas_grouped = {}
            for runData in runDatas:
                groupname = runData.rundir.group
                runDatas_grouped.setdefault( groupname, [] ).append( runData )

            for valuename in valuenames:
                for groupname, runDatas_group in runDatas_grouped.items():
                    runDatas_group = filter( lambda x: x.valuename == valuename, runDatas_group )
                    tables = map( lambda x: x.table, runDatas_group )
                    xcolname = runDatas_group[0].xcolname
                    classifications = [ x.rundir.classification for x in runDatas_group ]
                    rundirs = [ x.rundir for x in runDatas_group ]

                    if len(runDatas_group) < 2:
                        err( "Not enough runs for meta (" + groupname + ")" )

                    for valueattr in valueattrs['meta']:
                        if valueattr == 'default' or valueattr == 'min' or valueattr == 'max':
                            if valueattr == 'default':
                                ycolname = runData.ycolname_default
                            else:
                                ycolname = valueattr

                            table_meta = algorithms.avr_table_from_tables( 'Meta-%s-%s-%s' % (groupname, valuename, valueattr),
                                                                           tables,
                                                                           xcolname,
                                                                           ycolname )
                            write_temp_table( table_meta )

                            ycolnames = ['mean']
                            curvetype = 'line'

                        elif valueattr == 'err':
                            table_meta = algorithms.avr_table_from_tables( 'Meta-%s-%s-%s' % (groupname, valuename, valueattr),
                                                                           tables,
                                                                           xcolname,
                                                                           runData.ycolname_default )
                            write_temp_table( table_meta )

                            ycolnames = ['mean', 'mean_stderr']
                            curvetype = 'errorbar'

                        elif valueattr == 'whisker':
                            table_meta = algorithms.avr_table_from_tables( 'Meta-%s-%s-%s' % (groupname, valuename, valueattr),
                                                                           tables,
                                                                           xcolname,
                                                                           runData.ycolname_default )
                            write_temp_table( table_meta )

                            ycolnames = ['q1','min','max','q3','median']
                            curvetype = 'whisker'

                        else:
                            err("impl")

                        curveDatas.append( CurveData(clause = self,
                                                     valuename = valuename,
                                                     valueattr = valueattr,
                                                     datatype = 'meta',
                                                     curvetype = curvetype,
                                                     table = table_meta,
                                                     xcolname = xcolname,
                                                     ycolnames = ycolnames,
                                                     yaxis = general_opts['yaxis'],
                                                     groups = [groupname],
                                                     rundirs = rundirs,
                                                     classifications = classifications) )

        #
        # Create ttest CurveData
        #
        if len( valueattrs['ttest'] ):
            runDatas_grouped = {}
            for runData in runDatas:
                groupname = runData.rundir.group
                runDatas_grouped.setdefault( groupname, [] ).append( runData )

            if len(runDatas_grouped) < 2:
                err( "ttest requires 2 groups." )
            elif general_opts['tgroups'] == None:
                if len(runDatas_grouped) > 2:
                    err( "More than 2 groups. Please use --tgroups for ttest calculations." )
                tgroups = runDatas_grouped.keys()
            else:
                tgroups = general_opts['tgroups'].split( ',' )
                if len(tgroups) != 2:
                    err( "Invalid --tgroups argument. Expecting 2 comma-separated values." )
                try:
                    tgroups = common_functions.expand_abbreviations( tgroups,
                                                                     runDatas_grouped.keys(),
                                                                     case_sensitive = False )
                except common_functions.IllegalAbbreviationError, x:
                    err( "Failed processing --tgroups: " + str(x) )

            if tgroups[0] == tgroups[1]:
                err( "ttest groups cannot be the same!" )
                     
            group1 = tgroups[0]
            group2 = tgroups[1]

            for valuename in valuenames:
                runDatas_group1 = filter( lambda x: x.valuename == valuename, runDatas_grouped[group1] )
                runDatas_group2 = filter( lambda x: x.valuename == valuename, runDatas_grouped[group2] )
                tables1 = map( lambda x: x.table, runDatas_group1 )
                tables2 = map( lambda x: x.table, runDatas_group2 )
                
                if len(tables1) != len(tables2):
                    warn( "For TTest, Numbers of runs different between groups. Some runs ignored." )
                
                ntables = min( len(tables1), len(tables2) )

                xcolname = runDatas_group1[0].xcolname
                ycolname = runDatas_group1[0].ycolname_default
                table_ttest = algorithms.ttest_table( 'TTest-%s' % valuename,
                                                      GlobalOptions.tcrit,
                                                      tables1[:ntables],
                                                      tables2[:ntables],
                                                      xcolname,
                                                      ycolname )

                write_temp_table( table_ttest )

                classifications = [ x.rundir.classification for x in runDatas_group1 + runDatas_group2 ]
                rundirs = [ x.rundir for x in runDatas_group1 + runDatas_group2 ]

                for valueattr in valueattrs['ttest']:
                    curveDatas.append( CurveData(clause = self,
                                                 valuename = valuename,
                                                 valueattr = valueattr,
                                                 datatype = 'ttest',
                                                 curvetype = 'line',
                                                 table = table_ttest,
                                                 xcolname = xcolname,
                                                 ycolnames = [valueattr],
                                                 yaxis = 2,
                                                 groups = tgroups,
                                                 rundirs = rundirs,
                                                 classifications = classifications) )
            
        #
        # Remove any error bar curves from list and link them to
        # their associated curve.
        #
        for curveData in curveDatas:
            if curveData.curvetype == 'errorbar':
                line = None
                for x in curveDatas:
                    if ( x.rundirs == curveData.rundirs
                         and x.groups == curveData.groups
                         and x.valuename == curveData.valuename
                         and x.valueattr == 'default'
                         and x.curvetype == 'line' ):
                        line = x
                        break
                assert( line )
                line.errorbar = curveData

        curveDatas = filter( lambda x: x.curvetype != 'errorbar', curveDatas )


        #
        # Apply any general style options
        #
        for curveData in curveDatas:
            if curveData.curvetype == 'line':
                curveData.points = general_opts['dots']
                curveData.smooth = general_opts['smooth']

        return curveDatas
                    

####################################################################################
###
### FUNCTION write_temp_table()
###
####################################################################################
temp_tables = []
def write_temp_table( table ):
    datalib.write( '/tmp/plot-temp-table-%s.plt' % len(temp_tables), table )
    temp_tables.append( table )


####################################################################################
###
### FUNCTION classify_runs()
###
####################################################################################
def classify_runs( rundirs ):
    for rundir in rundirs:
        try:
            rundir.classification = common_functions.classify_run( rundir.path,
                                                                   single_classification = True,
                                                                   constraints = GlobalOptions.classifications )
        except common_functions.ClassificationError, x:
            warn( x )
            rundir.classification = 'NoClassification'


####################################################################################
###
### FUNCTION parse_cfg()
###
####################################################################################
def parse_cfg( rundir ):
    path = os.path.join( rundir.path, 'plot.cfg' )

    props = {}
    
    if os.path.exists( path ):
        for line in open( path ):
            fields = line.split()
            props[fields[0]] = " ".join( fields[1:] )
            
    return props


####################################################################################
###
### FUNCTION group_runs()
###
####################################################################################
def group_runs( rundirs ):
    overlay_parameter_names = get_overlay_parameter_names( rundirs )
    overlay_parameter_values = dict([ (rundir.path, get_parameter_values(overlay_parameter_names, rundir))
                                      for rundir in rundirs ])

    def __parentdir( rundir ):
        return os.path.basename(os.path.dirname(rundir.path))

    if GlobalOptions.group != 'auto':
        group_type = GlobalOptions.group
    else:
        group_type = 'classification'

        if len( set(overlay_parameter_values.values()) ) > 1:
            group_type = 'overlay'
        else:
            # If we're dealing with a collection of farm runs...
            if all( map(lambda x: os.path.exists( os.path.join(rundir.path, '.pwfarm/') ),
                        rundirs) ):

                # Use parent dir as group, so long as parent dir doesn't contain mix of classifications
                parentdir_classes = {}
                for rundir in rundirs:
                    parentdir_classes.setdefault( __parentdir(rundir), set() ).add( rundir.classification )

                if all( map(lambda classes: len(classes) == 1, parentdir_classes.values()) ):
                    group_type = 'parentdir'

    for rundir in rundirs:
        # Might already have group due to @group in argv
        if not rundir.group:
            if group_type == 'overlay':
                rundir.group = "(" + ",".join( overlay_parameter_values[rundir.path] ) + ")"
            elif group_type == 'parentdir':
                rundir.group = __parentdir( rundir ).capitalize()
            elif group_type == 'classification':
                rundir.group = rundir.classification
            else:
                err( "Invalid value for --group (%s)" % group_type )


####################################################################################
###
### FUNCTION config_style()
###
####################################################################################
def config_style( plot, curveDatas ):
    curveDatas_individual = filter( lambda x: x.datatype == 'individual', curveDatas )
    curveDatas_meta = filter( lambda x: x.datatype == 'meta', curveDatas )
    curveDatas_ttest = filter( lambda x: x.datatype == 'ttest', curveDatas )

    __linetypes = list( plotlib.CurveStyle.LINE_TYPES )

    ###
    ### TTest Curves
    ###
    if len(curveDatas_ttest):
        if len(curveDatas_ttest) > 1 and not GlobalOptions.color:
            err( "Plotting more than 1 ttest requires color (-c)." )

        colors = list( plotlib.CurveStyle.COLORS )
        # Use gray first. 
        colors.remove( plotlib.CurveStyle.GRAY )
        colors = [plotlib.CurveStyle.GRAY] + colors

        for curveData in curveDatas_ttest:
            curveData.style = plot.createCurveStyle( TTEST_LINETYPE,
                                                     plotlib.CurveStyle.THICK,
                                                     colors.pop(0) )            

    ###
    ### Individual Curves
    ###
    if len(curveDatas_individual):
        linetypes = list( __linetypes )

        if GlobalOptions.color:
            colors = dict([ (linetype, list(plotlib.CurveStyle.COLORS) ) for linetype in linetypes ])

        for curveData in curveDatas_individual:
            assert( len(curveData.classifications) == 1 )
            classification = curveData.classifications[0]
            if classification in CLASSIFICATION_LINETYPES:
                linetype = CLASSIFICATION_LINETYPES[classification]
            else:
                linetype = plotlib.CurveStyle.SOLID

            if GlobalOptions.color:
                if len(colors[linetype]) == 0:
                    err( "Ran out of colors for individual runs!" )
                color = colors[linetype].pop(0)
            else:
                color = plotlib.CurveStyle.GRAY

            curveData.style = plot.createCurveStyle( linetype,
                                                     plotlib.CurveStyle.THIN,
                                                     color )
            

    ###
    ### Meta Curves
    ###
    if len(curveDatas_meta):        
        if not GlobalOptions.color:
            ###
            ### Black-only Meta
            ###

            linetypes = list( __linetypes )

            # First, try to assign classification-preferred linetypes. We can only
            # do that if the curve has a single classification.
            for curveData in curveDatas_meta:
                if len(curveData.classifications) == 1:
                    classification = curveData.classifications[0]
                    if classification in CLASSIFICATION_LINETYPES:
                        linetype = CLASSIFICATION_LINETYPES[classification]
                        # Make sure we haven't already used this linetype.
                        if linetype in linetypes:
                            linetypes.remove( linetype )
                            curveData.style = plot.createCurveStyle( linetype,
                                                                     plotlib.CurveStyle.THICK,
                                                                     plotlib.CurveStyle.BLACK )

            # Assign available linetypes to remaining curves.
            for curveData in curveDatas_meta:
                if hasattr( curveData, 'style' ):
                    continue

                if len(linetypes) == 0:
                    warn( "Number of meta curves exceeds number of line types. Consider using color (-c)." )
                    linetypes = list( __linetypes )

                linetype = linetypes.pop( 0 )
                curveData.style = plot.createCurveStyle( linetype,
                                                         plotlib.CurveStyle.THICK,
                                                         plotlib.CurveStyle.BLACK )
        else:
            ###
            ### Color Meta
            ###
            colors = dict([ (linetype, [plotlib.CurveStyle.BLACK] + list(plotlib.CurveStyle.COLORS) ) for linetype in __linetypes ])
            
            for curveData in curveDatas_meta:
                linetype = None

                # Try to use classification linetype
                if len(curveData.classifications) == 1:
                    classification = curveData.classifications[0]
                    if classification in CLASSIFICATION_LINETYPES:
                        linetype = CLASSIFICATION_LINETYPES[classification]

                if not linetype:
                    # Fall back to default. Might need to eventually allow multiple line types if we run out of colors
                    linetype = plotlib.CurveStyle.SOLID

                if not len(colors[linetype]):
                    err( "Ran out of meta colors! Try adding more colors or code that cycles line types" )

                curveData.style = plot.createCurveStyle( linetype,
                                                         plotlib.CurveStyle.THICK,
                                                         colors[linetype].pop(0) )

    
####################################################################################
###
### FUNCTION get_overlay_parameter_names()
###
####################################################################################
def get_overlay_parameter_names( rundirs ):
    result = set()

    for rundir in rundirs:
        result.update( wfutil.get_overlay_parameter_names(rundir.path) )

    return result


####################################################################################
###
### FUNCTION get_parameter_values()
###
####################################################################################
def get_parameter_values( parameter_names, rundir ):
    result = []
    for parameter_name in parameter_names:
        result.append( wfutil.get_parameter(rundir.path, parameter_name) )

    return tuple( result )


####################################################################################
###
### FUNCTION create_macros()
###
####################################################################################
def create_macros( clauses,
                   rundirs,
                   curveDatas ):

    overlay_parameter_names = get_overlay_parameter_names( rundirs )
    overlay_parameter_values = set( [ get_parameter_values(overlay_parameter_names, rundir)
                                      for rundir in rundirs ] )
    if len( overlay_parameter_values ) <= 1:
        use_overlay = False
    else:
        use_overlay = True

    groups = set([group
                  for curveData in curveDatas
                  for group in curveData.groups])
    modes = set([ clause.mode.title for clause in clauses ])

    # Create string like: Neural Complexity(Processing), Agents
    def __mode_values( curveDatas ):
        modevalues = {}
        for curveData in curveDatas:
            modename = curveData.clause.mode.name
            valuename = curveData.valuename
            modevalues.setdefault( modename, set() ).add( valuename )

        modevalues = ", ".join([ Mode.get_mode(x[0]).get_valuenames_title( x[1] )
                                 for x in modevalues.items() ])
        return modevalues
        
    modevalues = __mode_values( curveDatas )
    y1values = __mode_values( filter(lambda x: x.yaxis == 1, curveDatas) )
    y2values = __mode_values( filter(lambda x: x.yaxis == 2 and x.datatype != 'ttest', curveDatas) )

    title = '{MODE_VALUES}'
    if use_overlay:
        title = title + ' -- Varying ({OVERLAY_PARMS})'
    elif len( groups ) > 1 and len( groups ) < 4:
        title = '{GROUPS} -- ' + title
    
    macros = {'TITLE': title,
              'XLABEL': 'Time',
              'Y1LABEL': '{Y1VALUES}',
              'Y2LABEL': '{Y2VALUES}',
              'Y1VALUES': y1values,
              'Y2VALUES': y2values,
              'MODES': ', '.join(modes),
              'MODE_VALUES': modevalues,
              'GROUPS': ' vs. '.join(groups) if len(groups) == 2 else ', '.join(groups),
              'OVERLAY_PARMS': ', '.join( overlay_parameter_names )}

    return macros


####################################################################################
###
### FUNCTION config_legend()
###
####################################################################################
def config_legend( plot, curveDatas ):
    curveDatas_individual = filter( lambda x: x.datatype == 'individual', curveDatas )
    curveDatas_meta = filter( lambda x: x.datatype == 'meta', curveDatas )
    curveDatas_ttest = filter( lambda x: x.datatype == 'ttest', curveDatas )

    groups = set([group
                  for curveData in curveDatas
                  for group in curveData.groups])

    def __valuetitle( curveData ):
        if curveData.valueattr != 'default':
            title = curveData.valueattr + " "
        else:
            title = ""
        title += curveData.valuename
        return title

    ###
    ### TTest
    ###
    if len(curveDatas_meta):
        if GlobalOptions.legend_meta:
            for curveData in curveDatas_ttest:
                curveData.title = __valuetitle( curveData )
        else:
            for curveData in curveDatas_ttest:
                curveData.title = None

    ###
    ### Meta
    ###
    if len(curveDatas_meta):
        if GlobalOptions.legend_meta:
            valuetitles = set([ __valuetitle(x) for x in curveDatas_meta ])

            for curveData in curveDatas_meta:
                if len(curveDatas_individual) and GlobalOptions.legend_individual:
                    title = "Meta "
                else:
                    title = ""

                if len(valuetitles) > 1:
                    title += __valuetitle(curveData)

                if len(groups) > 1:
                    assert( len(curveData.groups) == 1 )
                    groupname = curveData.groups[0]
                    if len(title):
                        title += " " + groupname
                    else:
                        title += groupname

                curveData.title = title
        else:
            for curveData in curveDatas_meta:
                curveData.title = None

    ###
    ### Individual
    ###
    if len(curveDatas_individual):
        if GlobalOptions.legend_individual:
            # Make scalar versions of tuples, for convenience
            for curveData in curveDatas_individual:
                assert( len(curveData.groups) == 1 )
                curveData.group = curveData.groups[0]
                assert( len(curveData.rundirs) == 1 )
                curveData.rundir = curveData.rundirs[0]

            valuetitles = set([ __valuetitle(x) for x in curveDatas_individual ])

            groupruns = {}

            for curveData in curveDatas_individual:
                groupruns.setdefault(curveData.group, set()).add( curveData.rundir.path )

            def __path_id( runs ):
                runs = list( runs )
                short_paths = common_functions.truncate_paths( runs )
                if len( set(short_paths) ) == 1:
                    short_paths = ["" for x in short_paths]
                return dict([ (runs[i], short_paths[i]) for i in range(len(runs)) ])

            path_ids = {}
            for group, runs in groupruns.items():
                path_ids.update(  __path_id(runs) )

            for curveData in curveDatas_individual:
                title = ''
                if len(valuetitles) > 1:
                    title += __valuetitle( curveData )

                path_id = path_ids[curveData.rundir.path]
                if len(groupruns.keys()) > 1:
                    if len(path_id):
                        path_id = curveData.group + " [" + path_id + "]"
                    else:
                        path_id = curveData.group

                if len(path_id):
                    if len(title):
                        title += "(" + path_id + ")"
                    else:
                        title = path_id

                curveData.title = title

        else:
            for curveData in curveDatas_individual:
                curveData.title = None
    
    ###
    ### Sort to dictate legend order.
    ###
    ### Note that curves are rendered from start to finish, so curves at end of
    ### list obscure curves at beginning. So, we want meta and ttest at end. 
    ###
    def __key( curveData ):
        key = ""
        if curveData.title:
            if curveData.datatype == 'ttest':
                key += "2,"
            elif curveData.datatype == 'meta':
                key += "1,"
            else:
                key += "0,"

            key += curveData.title

            return key

    curveDatas.sort( key = __key )
    
####################################################################################
###
### FUNCTION init_plot()
###
####################################################################################
def init_plot( macros, curveDatas):
    doc = plotlib.Document()
    doc.nocolor = not GlobalOptions.color

    title = expand_macros( GlobalOptions.title, macros )
    plot = doc.createPlot( title )

    ttest_curveDatas = filter( lambda x: x.datatype == 'ttest', curveDatas )
    y2_curveDatas = filter( lambda x: x.yaxis == 2 and x.datatype != 'ttest', curveDatas )

    if not len(ttest_curveDatas):
        if len(y2_curveDatas):
            plot.y2ticks = True
            plot.rmargin = 10
        else:
            plot.rmargin = 4

        if GlobalOptions.y2range:
            plot.y2range = GlobalOptions.y2range

        plot.y2label = expand_macros( GlobalOptions.y2label, macros )
    else:
        pval_curveDatas = filter( lambda x: x.ycolnames[0] == 'pval', ttest_curveDatas )
        tval_curveDatas = filter( lambda x: x.ycolnames[0] == 'tval', ttest_curveDatas )

        if len( y2_curveDatas ):
            err( "Cannot plot curves on y2axis when using ttest" )

        if len(pval_curveDatas) and len(tval_curveDatas):
            err( "Cannot plot both pval and tval" )

        if len(pval_curveDatas):
            tmin = 0.8
            tmax = 1.0

            plot.y2label = "(1 - p-value)       Dependent Student's T-test"

            plot.createTick( 0.8 )
            plot.createTick( 0.95,
                             line = True )
            plot.createTick( 1.0,
                             "1.0",
                             line = True,
                             linetype = plotlib.CurveStyle.DOTTED)
        else:
            tmin = 0
            tmax = GlobalOptions.tcrit

            for curveData in tval_curveDatas:
                tmax = max( tmax,
                            max(curveData.table.getColumn( 'tval' )) )

            plot.y2label = "Dependent Student's T-test (p < 0.05)"

            plot.createTick( GlobalOptions.tcrit,
                             "T*",
                             line = True )

        #
        # Set y2 range based on --ttop and --tbottom
        #
        if GlobalOptions.ttop <= GlobalOptions.tbottom:
            err( "ttop must be > tbottom" )

        y2len = (tmax - tmin) / (GlobalOptions.ttop - GlobalOptions.tbottom)
        y2bot = tmin - ( GlobalOptions.tbottom * y2len )
        plot.y2range = (y2bot, y2bot + y2len)

    plot.xlabel = expand_macros( GlobalOptions.xlabel, macros )
    plot.y1label = expand_macros( GlobalOptions.y1label, macros )

    if GlobalOptions.xrange:
        plot.xrange = GlobalOptions.xrange

    if GlobalOptions.y1range:
        plot.y1range = GlobalOptions.y1range

    plot.legend = GlobalOptions.legend_individual or GlobalOptions.legend_meta

    if GlobalOptions.rmargin:
        plot.rmargin = GlobalOptions.rmargin
            
    return doc, plot


####################################################################################
###
### FUNCTION finalize_plot()
###
####################################################################################
def finalize_plot( doc, plot ):
    path_doc, path_script = doc.save( GlobalOptions.output )
    if GlobalOptions.view:
        os.system( '%s %s' % (common_functions.pw_env('open'), path_doc) )


####################################################################################
###
### FUNCTION plot_curve()
###
####################################################################################
def plot_curve( plot,
                curveData ):

    if curveData.curvetype == 'line':
        curve = plot.createCurve( curveData.table,
                                  curveData.title,
                                  curveData.xcolname,
                                  curveData.ycolnames[0],
                                  curveData.style,
                                  curveData.smooth,
                                  curveData.points)
        curve.axes[1] = curveData.yaxis

        if hasattr( curveData, 'errorbar' ):
            curveData.errorbar.style = curveData.style
            plot_curve( plot, curveData.errorbar )

    elif curveData.curvetype == 'whisker':
        curve = plot.createCandlestickCurve( curveData.table,
                                             curveData.title,
                                             curveData.xcolname,
                                             curveData.ycolnames[0],
                                             curveData.ycolnames[1],
                                             curveData.ycolnames[2],
                                             curveData.ycolnames[3],
                                             curveData.style,
                                             plotlib.CandlestickCurve.WHISKERS )
        curve.axes[1] = curveData.yaxis

        curve = plot.createCandlestickCurve( curveData.table,
                                             None,
                                             curveData.xcolname,
                                             curveData.ycolnames[4],
                                             curveData.ycolnames[4],
                                             curveData.ycolnames[4],
                                             curveData.ycolnames[4],
                                             curveData.style,
                                             not plotlib.CandlestickCurve.WHISKERS )
        curve.axes[1] = curveData.yaxis

    elif curveData.curvetype == 'errorbar':
        curve = plot.createErrorbarCurve( curveData.table,
                                          None,
                                          curveData.xcolname,
                                          curveData.ycolnames[0],
                                          curveData.ycolnames[1],
                                          curveData.style)
        curve.axes[1] = curveData.yaxis


####################################################################################
###
### FUNCTION show_usage()
###
####################################################################################
def show_usage(msg = None, arg = None):
    if arg == None:
        usage_default()
    elif arg == 'opts':
        usage_opts()
    elif arg == 'macros':
        usage_macros()
    elif Mode.is_name( arg ):
        usage_mode( Mode.get_mode(arg) )
    else:
        print '\nInvalid help topic (%s)\n' % arg
        usage_default()

    if msg:
        print "--------------------------------------------------------------------------------"
        print
        print 'Error!', str(msg)

    sys.exit(1)

####################################################################################
###
### FUNCTION usage_default()
###
####################################################################################
def usage_default():
    print """\
USAGE 

     plot help [<mode>|opts|macros]
     plot [<global_opts>] <mode> [<mode_opts>] [ : <mode> [<mode_opts>]]... <directory>...

DESCRIPTION

     Plots results of one or more Polyworld runs.

     The type of data from a Polyworld run that is to be plotted is specified by
     the 'mode' argument, where valid modes are:

          %s

     Note that mode names may be abbreviated, but for help "opts" and "macros" must be
     spelled fully.

     Directory arguments can specify a run directory or the parent of one or
     more run directories.

     Note that all 'meta' averages can only be calculated if more than one run
     is specified. Meta-averages are computed only for those timesteps which exist
     for all runs.

     You may plot curves using multiple modes via ":", for example:

        plot n  : g ./run

     If you want to plot curves with drastically different y ranges, then you may
     use the y2 axis. For example, synapse counts are often in the thousands but
     neural groups < 100, but you can effectively plot them together like:

        plot s -v CurNeurGroups : s --y2 -v CurSynapses ./run
 
""" % ("\n          ".join(Mode.get_names()))
#-------------------------------------------------------------------------------


####################################################################################
###
### FUNCTION usage_opts()
###
####################################################################################
def usage_opts():
    print """\
GLOBAL OPTIONS

     -o, --output  <path>
               Specify path of generated plot document.
               (default %s)

     -C, --classifications <class>[,<class>]...
               <class>[,<class>]...: Constrain set of possible classifications,
            where choices are:
               %s
            Note that classification names are case-insensitive and needn't be
            fully spelled -- only enough to disambiguate (e.g. dri = Driven,
            P = Passive, f = Fitness).

     -g, --group <type>
               Specify method for grouping runs. Note that the use of @group will
            override any automatic grouping. Valid types are:

               auto - Attempt to automatically determine best method (default)
               classification - Use run classification
               overlay - Use overlay parameter values
               parentdir - Use name of run dir's parent dir

            Note you may use abbreviations.

     --xrange <xmin>,<xmax>
               Specify min and max x values.

     --y1range <ymin>,<ymax>
               Specify min and max y values of plot for y1-axis.

     --y2range <ymin>,<ymax>
               Specify min and max y values of plot for y2-axis.

     --tgroups <group1>,<group2>
               Specify groups used in ttest T-test calculations.

     --tcrit <TCRIT>
               Specify value of T* (default %f, which corresponds to %d
            samples in %d pairs in a Dependent Student's T-test)

     --tbottom <bottom>
               For ttest, specify where on the y2 axis the min value will be located.
            Value can be any number between 0 and 1, where 0 = bottom of plot and
            1 = top. (default '0')

     --ttop <top>
               For ttest, specify where on the y2 axis the max value will be located.
            Value can be any number between 0 and 1, where 0 = bottom of plot and
            1 = top. (default '0.25')

     -l, --legend
               Display a legend for the individual runs.
            (default is to not display a runs legend)

     -L, --noLegend
               Do not display a legend for groups.
            (default is to display a groups legend, if multiple groups
            are present)

     -V, --noview
               Do not show document in default viewer.

     -c, --color
               Use color to distinguish individual runs.
               (default is to use uniform gray for individual runs)

     --title <title>
               Specify title of graph, optionally with macros (see 'help macros').

     --xlabel <label>
               Specify label of x-axis, optionally with macros (see 'help macros').

     --y1label <label>
               Specify label of y1-axis, optionally with macros (see 'help macros').

     --y2label <label>
               Specify label of y2-axis, optionally with macros (see 'help macros').

     --rmargin <n>
               Override size of right margin, where n is number of character
            widths. Necessary because of buggy gnuplot behavior.
""" % (DEFAULT_OUTPUT,
       ', '.join(common_functions.CLASSIFICATIONS),
       TCRIT_DEFAULT[0], TCRIT_DEFAULT[1], TCRIT_DEFAULT[2])

####################################################################################
###
### FUNCTION usage_macros()
###
####################################################################################
def usage_macros():
    print """\
MACROS

        Macros are allowed in the title, xlabel, and y1label options. Their
     names must be enclosed within {}.

     Available macros:

     TITLE               Standard title

     XLABEL              Standard x-axis label

     Y1LABEL             Standard y1-axis label

     Y2LABEL             Standard y2-axis label

     Y1VALUES            Names of values on y1-axis

     Y2VALUES            Names of values on y2-axis

     MODES               List of modes being plotted.

     MODES_VALUES        List of all values being plotted, grouped by mode.

     OVERLAY_PARMS       Names of parameters being changed in overlay file.

     GROUPS              List of groups.
"""

####################################################################################
###
### FUNCTION usage_mode()
###
####################################################################################
def usage_mode( mode ):
    print "USAGE"
    print

    #
    # Usage
    #
    if mode.name == 'adhoc':
        print "     adhoc [<opts>] <relpath> <table> <x-column> <y-column>"
    else:
        print "     %s [<opts>]" % mode.name

    print """
OPTIONS
     (use 'help opts' to see global options)
    """

    #
    # -r recent_type
    #
    if mode.default_recent_type:
        print """\
     -r <recent_type>
               Valid recent types:%s
               Note names may be abbreviated.
               ( default = %s )
        """ % ( "\n                  ".join([''] + common_functions.RECENT_TYPES), mode.default_recent_type )

    #
    # -v
    #
    mode.usage_valuenames()

    #
    # AVR flags
    #
    if mode.isAvr:
        print """\
     -m/M
               Plot mean/meta-mean of each value (-v) type. (default -m on)

     -n/N
               Plot max/meta-max of each value (-v) type.

     -x/X
               Plot max/meta-max of each value (-v) type.

     -e/E
               Draw Standard Error bars for the mean/meta-mean.

     -w/W
               Box-and-Whiskers plot of run/meta-average.
        """
    #
    # valueattrs for all others
    #
    else:
        print """\
     -m/M
               Plot data/meta-data. (default -m on)

     -E
               Draw Standard Error bars for the meta-data.
        """

    #
    # options for all modes
    #
    print """\
     --tgroups <group1>,<group2>
               For this clause, specify groups used in ttest T-test calculations.

     -p
               Plot T-test p-values (see --tgroups for specifying groups).

     -t
               Plot T-test t-values (see --tgroups for specifying groups).

     -s
               Render smooth curves.

     -d
               Render dots/points.

     --y2
               Place curves on y2-axis.
    """

####################################################################################
###
### Primary Code Path
###
####################################################################################

exit_value = main()

sys.exit(exit_value)
